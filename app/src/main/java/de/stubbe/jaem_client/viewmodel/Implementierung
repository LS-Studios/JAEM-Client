 // Initial einen EncryptionHelper erstellen für user
//
// ED pub und private keys
// x pub und private keys
// ed pub und x pub für chat vom empfänger
val userClient = ED25519Client(otherPubEd, otherPubX, otherPrivateEd, otherPrivateX)
val otherClient = ED25519Client(otherPubEd, otherPubX)
val userEncryption = EncryptionHelper(SymmetricEncryption.ED25519, userClient)

//IM Chat
val chatEncryption = userEncryption
chatEncryption.setCommunicationPartner(otherClient)

chatEncryption.encrypt("Hallo".toByteArray())

//Bei Erster nachicht
//
AsymmetricEncryption.RSA.decrypt(Message, otherClient.publicKey)

// Zunkunft rsa reset





Nutzer:
ED PUB
X PUB
RSA PUB

AES -> Immer bei erstllung des Chats (NICK)

Device:
ED PUB
ED PRIVATE
X PUB
X PRIVATE
RSA PUB
RSA PRIVATE

AES -> Immer bei erstllung des Chats (NICK)

Bei Nachicht Senden:
1. Byte für Algorithmus (0 -> ED)
2. + 32 Byte ED PUB von Empfänger
3. (Message + ED PUB) -> Signatur mit ED PRIVATE
4. (Signatur + Message) -> AES verschlüsseln
5. ED PUB + AES Verschlüsselt -> RSA verschlüsseln
6. 1 + 2 + RSA Verschlüsselt
7. Send Message an Server

Bei Nachicht Empfangen:
1. UNIX Zeitstempel
2. Zeitstempel Signieren mit ED PRIVATE
3. POST an get messages -> Algorithmus + signatur + ED PUB + Zeitstemel
4. Selbser Splitten (Jede nachicht 8 Byte wie lange die Nachicht)